# TCP
애플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 확실하게 전달하기 위한 프로토콜이다.
TCP는 애플리케이션으로부터 받고 다시 애플리케이션에게 전달하는 것을 담당하고, 상대 서버에게 전송하는 부분은 하위계층인 IP에게 위임한다.
TCP에 의존하지 않고 IP만으로도 통신할 수 있지만, IP에는 데이터가 상대방에게 확실히 전달됐는지 확인하는 기능이나 도착한 순서를 확인하는 기능이 없다.

대표적인 기능으로는 
* 포트번호를 이용한 데이터 전송
* 연결 생성
* 데이터 보증과 재전송 제어
* 흐름 제어와 혼잡 제어

## 커널 공간의 TCP 처리 흐름
TCP는 데이터를 세그먼트(Segment)라고 하는 단위로 관리한다.
상위 계층에서 받은 애플리케이션 데이터에 TCP 헤더를 붙여서 TCP 세그먼트를 작성한다.
헤더에는 도착 지점 포트 번호를 포함하여 TCP 기능을 표현하기 위한 수많은 정보가 기록된다.

예를 들어, 2000바이트의 데이터가 애플리케이션에 의해 소켓에 기록되었다면
많은 환경에서 최대 전송가능한 데이터 크기인 1460바이트보다 크기때문에 1460바이트와 540바이트의 데이터로 분할해야 한다.
이 때 각각의 TCP 헤더를 붙여서 두 개의 TCP 세그먼트가 만들어진다.
![](https://velog.velcdn.com/images/tme2685/post/4f27a6ce-c47a-461e-a525-e2424cb8cf14/image.png)

## 포트 번호를 이용한 데이터 전송
상대 서버에 데이터가 도착했다고 해도 어떤 애플리케이션용 데이터인지 알 수 없다.
TCP에서는 포트 번호를 사용해서 어떤 애플리케이션에 데이터를 전달할지 판단한다.

## 연결 생성
TCP는 연결형 프로토콜으로 연결이라 부르는 가상 경로를 생성한다.
이 경로는 처음 통신을 시작할 때 3-way handshaking을 통해서 생성된다.
이 연결은 두 컴퓨터 사이에 전용 회선이 있는 것처럼 통신한다.

## 데이터 보증과 재전송 제어
연결이 생성되면 데이터 송수신을 시작한다.
TCP에는 데이터가 확실히 전달되도록 보증하는 기능이 있다.

### 데이터 손실을 방지하는 구조
수신 측에 TCP 세그먼트가 도착하면 송신 측으로 도착했다는 것을 알린다.
이때 반환하는 것을 ACK이라고 하며 TCP헤더에 ACK관련 정보를 넣은 TCP 세그먼트를 반환한다.
만약 ACK이 돌아오지 않으면 어떤 이유로 통신이 안 되었을 가능성이 있기 때문에 언제든지 재전송이 가능하도록 TCP 세그먼트를 버퍼에 남겨둘 필요가 있다.

### 데이터 순서를 보증하는 구조
각 TCP 세그먼트에 시퀀스 번호를 붙여서 구현한다.
이것도 헤더에 기록되며 해당 세그먼트가 전체 중 몇 바이트에서 시작하는지를 나타낸다.
예를 들어 3000바이트를 보낼 때 1460, 1460, 80 의 3 개의 세그먼트로 보낸다면
첫 번째 세그먼트의 시퀀스 번호를 1
두 번째 세그먼트의 시퀀스 번호를 1461
세 번째 세그먼트의 시퀀스 번호를 2921 이라고 한다.
수신 측은 이 번호를 사용하여 데이터를 조립한다.


### TCP 재전송 제어
수신 측은 ACK을 반환할 때 다음에 필요한 세그먼트의 시퀀스 번호를 전달한다.
위의 예에서 두 번째 세그먼트까지 받았으면, 필요한 세그먼트의 시퀀스 번호인 2291부터 보내라는 내용을 담아서 보낸다.

ACK이 오지않으면 재전송을 해야 한다. 
1. 일정 시간내에 ACK이 돌아오지 않으면 재전송한다.
2. 같은 시퀀스 번호로 3회 중복 ACK이 돌아온다면 재전송한다.
![](https://velog.velcdn.com/images/tme2685/post/09df774d-3206-4744-9f81-eeca2ab7b762/image.png)

## 흐름 제어와 혼잡 제어
[흐름제어와 혼잡제어](https://velog.io/@tme2685/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4)

# IP
지정한 대상 서버까지 전달받은 데이터를 전해주는 프로토콜이다.
주요 기능으로는
* IP 주소를 이용한 최종 목적지로의 데이터 전송
* 라우팅

## 커널 공간의 IP 처리 흐름
생성된 TCP 세그먼트를 그대로 IP 처리한다.
IP 계층에서는 최종 목적지가 적힌 IP 헤더를 TCP 세그먼트에 추가해서 IP 패킷을 생성한다.
헤더에는 목적지 IP 주소, 데이터 길이, 프로토콜 종류, 헤더 체크섬 등이 기록된다.
TCP 계층에서 분할했기 때문에 여기에 IP헤더만 추가한다.

## IP 주소를 이용한 최종 목적지로의 데이터 전송
IP에서는 최종 목적지 서버까지 여러 네트워크를 경유해서 데이터를 전송한다.
IP 주소는 네트워크부와 호스트부로 나뉘는데, 네트워크부는 어떤 네트워크인지를 가리키고, 호스트부는 해당 네트워크 내에 있는 컴퓨터를 가리킨다.
어디까지가 네트워크부인지 표시하기 위해서 '/24'와 같은 CIDR 표기를 사용한다.
또는 '255.255.255.0'과 같이 서브넷마스크로 표현하기도 한다.
![](https://velog.velcdn.com/images/tme2685/post/8a938aef-5fe1-4a4f-ac9c-8fc17fdd29bd/image.png)
IP 주소 중 호스트부의 비트가 모드 0인 것을 네트워크 주소, 모두 1인 것을 브로드캐스트 주소라고 한다.
이 2개는 호스트에 할당해서는 안 되는 특별한 IP 주소이다.
브로드캐스트 주소르 보낸 패킷은 같은 네트워크의 모든 호스트에 전달된다.

## 라우팅
서버내에서만 처리되는 TCP와 달리 IP는 경로 도중에 다양한 처리가 이루어진다.
라우팅도 그 중 하나이다.
IP 주소를 이용해 수신 서버를 지정할 수 있는데 수신 서버와 항상 같은 네트워크내에 있는 것이 아니다.
이 경우에는 최종 목적지에 도착할 떄까지 목적지를 알고 있는 라우터에게 전송을 부탁한다.
라우터는 해당 IP 패킷의 헤더에서 목적지를 확인해서 어디로 보낼지 확인해야 하는데 이때 사용하는 것이 '라우팅 테이블'이다.
서버나 라우터는 자신이 알고 있는 목적지 정보를 라우팅 테이블이라 하는 형태로 목록화한다.

이 떄 만약 라우터의 라우팅 테이블이 잘못 되어있다면 목적지를 못 찾고 엉뚱한 네트워크 안을 계속 순회하게 된다.
이런 상태를 방지하기 위해 TTL(Tiem To Live)라는 생존시간 정보를 가지고 있다.
예를 들어 TTL = 64라고 하면 라우터를 하나 경유할 때 마다 TTL을 1씩 줄인다.
그러다 TTL이 0이 된다면 라우터는 패킷을 파기한다.

